\input{prelude.tex}
\input{config.tex}


%%%%%%%%%%%%%%%%% END OF PREAMBLE %%%%%%%%%%%%%%%%

\begin{document}
\maketitle

%\include{Sections/Introduzione.tex}
%\include{Section2}
%\include{Section3}
%\include{Section4}
%\include{Conclusion}

%*******    Figure and Subfigure example ***********
%\begin{figure}[tbh]
% \includegraphics[width=1\linewidth]{circle}
% \caption[Circonferenza]{Circle}
% \label{fig:circle}
% \end{figure}%

% \begin{figure}[tbh]
% \begin{subfigure}{.5\textwidth}
% \includegraphics[width=1\linewidth]{circle}
% \caption[Circonferenza]{Circle}
% \label{fig:circle}
% \end{subfigure}%
% \begin{subfigure}{0.5\textwidth}
% \includegraphics[width=1\linewidth]{random}
% \caption[Random]{Random}
% \label{fig:random}
% \end{subfigure}
% \end{figure}
%%%***************************************%%

\section{Answers to the Questions}
\textbf{Q-A}: How many processes must your shell create when receiving a piped command? How many pipes? Until when must the shell wait to accept another command? \newline


\textbf{Q-B}:Can you implement a shell program which only utilizes threads (instead of processes)? If your answer is yes, then write a thread-based version of \texttt{mys}, call it \texttt{$mysh1_th$}, and include it in your submission. If your answer is no, explain why. \newline


\textbf{Q-C}: Can you use the \texttt{cd} command with shell \texttt{my}? Why?


\section{Programs Descriptions}
\subsection{\texttt{mysh1}}
This is the simple implementation of a shell that receives one command at a time (without arguments) and executes it. The source of the command is the standard input (\texttt{stdin}), which is the keyboard input stream. The \texttt{getline} function provides the entire content of one line of input from that stream (so it waits to return until the newline character is inserted). The content of the line is stored in the first argument that is passed, while the second one will contain the size of the buffer that is used to store the line. \newline

The call to \texttt{strtok} searches for the start of the command (it skips characters like spaces and tabs) and returns a pointer to that. If no command is found (the newline is inserted before any symbol that may be the start of a command) then the shell will ask for another input line. \newline

If a command is found, first it's compared to the \texttt{exit} directive (to exit the whole program), then a new process is started with the \texttt{fork()} system call to execute the program with the name of the command. The call to \texttt{execvp()} takes the name of the command to execute and searches it in the directories listed in the \textbf{PATH} environment variable.
When the child process has finished executing (or there was an error when calling \texttt{execvp}), it terminates. In the meantime, the parent process waits for the termination of any of its children with the invocation of \texttt{wait(NULL)}. In this case there is only one child to wait. After that, the parent return at the top of the cycle and waits for another command.
\subsection{\texttt{mysh2}}
To extend \texttt{mysh1} to accept arguments for the invoked commands, we used an array of pointers to the arguments. These pointer point towards the input string and are parsed using \texttt{strtok} to eliminate characters like spaces and tabs between each argument. \newline

For the sake of simplicity and correctness, we allocate each time new memory to use to store the array of pointers (we use dynamic allocation because we don't know the number of arguments that may be used) and we free the memory at every new command read. \\ 

\texttt{mysh2} makes use of these two functions:
\begin{itemize}
\item{\texttt{char **parseArguments(char *input, char *delim, int *size)}}: takes the string in \texttt{input} and a character array of delimiters and returns an array of pointers to tokens that are obtained from the initial input by separating the tokens with the \texttt{delim}'s characters. The number of tokens is saved in the variable \texttt{size} and the function return the array of pointers to the tokens.
\item{\texttt{void deallocation(char **array, int size)}}: this function takes an array of pointers to memory locations that were previously allocated with \texttt{malloc} and deallocates them with by invoking \texttt{free} for each pointer.
\end{itemize}

After the call to the function \texttt{parseArguments} has returned, in the array \texttt{args} we have:
\begin{itemize}
\item \texttt{args[0]}: contains the command to execute (the first token found);
\item \texttt{args[1]...args[size-1]}: have pointers to the arguments of the command;
\item \texttt{args[size]}: this is set to be NULL, since the call to \texttt{malloc} and \texttt{realloc} does not initialize the value of the new memory locations.
\end{itemize}

So the array \texttt{args} contains the command and the arguments for it, as required by the system call \texttt{execvp}, that is called by the child process to execute the command.

\subsection{\texttt{mysh3}}
\subsection{\texttt{syn1}}
\subsection{\texttt{syn2}}
\subsection{\texttt{synthread1}}
\subsection{\texttt{synthread2}}
\subsection{\texttt{syn1.java}}
\subsection{\texttt{syn2.java}}


\clearpage

%\bibbycategory % equivale a dare un \printbibliography per ogni categoria

\end{document}
